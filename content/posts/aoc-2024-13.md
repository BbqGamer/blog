+++
title = 'AoC 2024 Dzie - 13'
date = 2024-12-13T19:07:42+01:00
draft = false
tags = ["aoc"]
math = true
+++
# Zadanie
W dzisiejszym zadaniu musimy zagra w gr "szpon", mamy do dyspozycji dwa przyciski A i B
wcinicie przycisku A kosztuje nas 3 kredyty a B jeden. Ka偶dy przycisk ma zdefiniowany
wektor przesunicia szpona. Naszym zadaniem jest przesun szpona na pole z nagrod, w
jak najmniejszym kocie w kredytach.

Wynikiem jest minimalna suma kredyt贸w potrzebna do zdobycia nagr贸d w ka偶dej grze gdzie
jest to mo偶liwe.

Przykadowe dane:
```
Button A: X+94, Y+34
Button B: X+22, Y+67
Prize: X=8400, Y=5400

Button A: X+26, Y+66
Button B: X+67, Y+21
Prize: X=12748, Y=12176
```
W powy偶szym przykadzie mamy dwie gry, pierwsza jest niemo偶liwa do rozwizania, z kolei
w drugiej rozwizaniem jest wcisnprzycisk A 80 razy i przycisk B 40 razy, co daje 
razem 280 kredyt贸w
<p>
    \(80 \cdot 3 + 40 = 280\)
</p>

# Rozwizanie
Zacznijmy od parsowania danych, mo偶emy to w atwy spos贸b zrobi za pomoc wyra偶e 
regularnych:
```python
import re

PATTERN = (
    r"Button A: X\+(\d+), Y\+(\d+)\n"
    r"Button B: X\+(\d+), Y\+(\d+)\n"
    r"Prize: X=(\d+), Y=(\d+)"
)

res = 0
for x in re.finditer(PATTERN, sys.stdin.read()):
    xa, ya, xb, yb, xd, yd = map(int, x.groups())
    # xa,ya to wektor przesunicia przycisku A a xb,yb przycisku B 
    # xd i yd oznaczaj koordynaty nagrody (d jak destination)
```
Co dalej? Moj pierwsz myl byo rozwizanie tego za pomoc programowania dynamicznego.
Spr贸bujmy przygotowa rekurencyjn funkcj kt贸ra mogaby znale藕 nam wynik.
```python
@cache
def moves(x, y):
    if x == xd and y == yd:
        return 0  # nie musimy wyda wicej 偶eton贸w jak znajdziemy si na polu nagrody

    # jeli przestrzelimy nagrod 偶adna ilo token贸w nie bdzie w stanie jej zdoby
    if x > xd or y > yd:
        return float("inf")

    # wracamy ilo 偶eton贸w lepszego ruchu (tego co kosztuje ostatecznie mniej 偶eton贸w)
    return min(3 + moves(x + xa, y + ya), 1 + moves(x + xb, y + yb))
```
Gdy uruchomiem kod dostaem bd:
```
RecursionError: maximum recursion depth exceeded
```
Nie wr贸偶y to dobrze ale spr贸buj zwikszy maksymaln gboko rekurencji, kocowy kod
wyglda tak:
```python
import re
import sys
from functools import cache

sys.setrecursionlimit(1500)

PATTERN = (
    r"Button A: X\+(\d+), Y\+(\d+)\n"
    r"Button B: X\+(\d+), Y\+(\d+)\n"
    r"Prize: X=(\d+), Y=(\d+)"
)

res = 0
for x in re.finditer(PATTERN, sys.stdin.read()):
    xa, ya, xb, yb, xd, yd = map(int, x.groups())

    @cache
    def moves(x, y):
        if x == xd and y == yd:
            return 0

        if x > xd or y > yd:
            return float("inf")

        return min(3 + moves(x + xa, y + ya), 1 + moves(x + xb, y + yb))

    m = moves(0, 0)
    if m != float("inf"):
        res += m

print(res)
```
O dziwo zwikszenie limitu z domylnego 1000 na 1500 dziaa! Program nie jest jaki
super wydajny ale wystarczy to na razie. Zobaczmy cz drug.

# Cz 2
Okazuje si 偶e w tej czci do obu koordynat贸w nagrody musimy doda liczb
`10000000000000` .

Nawet nie pr贸buj uruchamia mojego poprzedniego rozwizania, ewidentnie potrzebne jest
tu bystrzejsze podejcie.

## Pomys
Mo偶emy zformuowaproblem minimizacji kosztu i u偶y jakiego solwera do programowania
liniowego. Zauwa偶my 偶e problem mo偶na przedstawi w taki spos贸b:
$$
min~3a + b \\\
a x_a + b x_b = x_d \\\
a y_a + b y_b = y_d
$$
Nasze jedyne zmienne to `a` oraz `b`, i musz one by w wyniku liczbami cakowitymi, co
nieco utrudnia spraw solverowi.

# Implementacja z u偶yciem scipy.optimize
```python
part2 = 0
for x in re.finditer(PATTERN, sys.stdin.read()):
    xa, ya, xb, yb, xd, yd = map(int, x.groups())
    xd += 10000000000000
    yd += 10000000000000

    c = [3, 1]
    A = [[xa, xb], [ya, yb]]
    b = [xd, yd]

    res = linprog(c, A_eq=A, b_eq=b, integrality=[3, 3])

    print(res.status)
    if res.status == 0:
        an, bn = map(int, res.x)
        part2 += int(res.fun)

print(part2)
```
Wreszcie na co przyday si te studia! Uruchamiamy kod i... Otrzymujemy bdny wynik :(

Okazuje si 偶e solver u偶ywa liczb zmiennoprzecinkowych pod spodem i przy tak du偶ych
wartociach, pojawiaj si bdy numeryczne, mo偶e by ci偶ko uzyska rozwizanie t 
drog.

W tym momencie sprawdziem jeszcze kilka innych solver贸w: `gurobi`, `pulp_cbc` jednak,
ka偶dy z nich mia taki sam problem, uznaem 偶e jest to chyba lepy zauek i musz szuka
innego rozwizania.

# Eureka
Po rozpisaniu sobie tego jeszcze kilka razy na papierze stao si jasne co co powinienem
by zobaczy du偶o wczeniej. Gdybym pamita cowicej z algebry liniowej to zauwa偶ybym
偶e dla ka偶dej gry s dwie opcje, albo mamy jedno rozwizanie albo nieskoczenie wiele.
Ukad r贸wna (kt贸ry z reszt napisaem na g贸rze), mo偶na bardzo atwo rozwiza liczc,
odwrotno macierze 2x2, jako 偶e jestem leniwy i nawet tego nie chce mi sirobi u偶yj
numpy 偶eby mi rozwiza cay ukad r贸wna.
```python
import re
import sys

import numpy as np

PATTERN = (
    r"Button A: X\+(\d+), Y\+(\d+)\n"
    r"Button B: X\+(\d+), Y\+(\d+)\n"
    r"Prize: X=(\d+), Y=(\d+)"
)

results = [0, 0]
TO_ADD = [0, 10000000000000]

for x in re.finditer(PATTERN, sys.stdin.read()):
    for i in range(2):
        xa, ya, xb, yb, xd, yd = map(int, x.groups())
        xd += TO_ADD[i]
        yd += TO_ADD[i]

        A = np.array([[xa, xb], [ya, yb]], dtype=np.int64)
        b = np.array([xd, yd], dtype=np.int64)
        resa, resb = np.round(np.linalg.solve(A, b))

        # sprawd藕my tylko czy po zaokrgleniu wynik jest poprawny
        if resa * xa + resb * xb == xd and resa * ya + resb * yb == yd:
            results[i] += 3 * resa + resb

print(int(results[0]))
print(int(results[1]))
```
W ten spos贸b otrzymujemy kod kt贸ry rozwizuje obie czci prawie natychmiastowo.

## Podsumowanie
Zadanie byo bardzo ciekawe, na pocztku za bardzo mylaem jak programista a za mao
jak matematyk. Nauczyem site偶 czegoo programowaniu liniowym, nie zawsze jest ono
najlepszym rozwizaniem, otrzymywanie dokadnych wynik贸w nie jest takie proste kiedy
nakadamy ograniczenia 偶e zmienne musz by liczbami cakowitymi.
