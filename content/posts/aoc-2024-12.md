+++
title = 'AoC 2024 Dzień - 12'
date = 2024-12-12T11:21:43+01:00
draft = true
tags = ["aoc"]
+++
# Zadanie
W dzisiejszym zadaniu musimy policzyć pola i obwody regionów na gridzie 2d, przykładowo:
```
AAAA
BBCD
BBCC
EEEC
```
Na powyższym gridzie mamy region A który ma pole 4 i obwód 10 (obwód liczymy jako ilość
sąsiadujących pól które nie są z tego regionu), region B ma pole 4 a obwód 8. Jednym z
problemów może być to że regiony mogą być też w środku innych regionów np:
```
AAA
AOA
AAA
```
Region A ma pole 8 ale obwód 16, a region O ma pole 1 i obwód 4

Na całej planszy może być kilka regionów z tą samą literką, ale jeśli nie są one połączone
to traktujemy je jako osobne regiony. 

Jako wynik musimy policzyć sumę pól wszystkich regionów pomnożonych przez ich obwody.

# Rozwiązanie
Na pierwszy rzut oka odpowiednim algorytmem na rozwiązanie tego zadania wydaje się być
DFS, będziemy rozpoczynać go od każdego pola w którym jeszcze nie byliśmy tak długo aż
wyczerpiemy wszystkie pola.

Oto struktura skryptu, później zajmiemy się implementacją dfsa

```python
import sys

data = [l.strip() for l in sys.stdin.readlines()]
to_visit = {(i, j) for i in range(len(data)) for j in range(len(data[i]))}

def dfs(i, j) ...

result = 0
while to_visit:
    i, j = to_visit.pop()
    area, perimeter = dfs(i, j)
    result += area * perimeter

print(result)
```

Żeby kod był bardziej czytelny zdefiniuję sobie kilka funkcji pomocniczych:
```python
def out_of_bound(i, j):
    # sprawdza czy nasze indeksy wychodzą poza pole
    return i < 0 or j < 0 or i >= len(data) or j >= len(data[0])

def neighborbood(i, j):
    # iteruje po sąsiadujących polach
    for di, dj in [(-1, 0), (0, -1), (1, 0), (0, 1)]:
        yield i + di, j + dj
```
Przechodząc do faktycznego mięsa, funkcja DFS prezentuje się tak:
```python
def dfs(i, j):
    area = 1
    peri = 0
    for ni, nj in neighborbood(i, j):
        # kiedy natrafimy na pole z innego regionu lub poza planszą zwiększamy obwód
        if out_of_bound(ni, nj) or data[ni][nj] != data[i][j]:
            peri += 1
            continue

        # ignorujemy pola z tego samego regionu na których już byliśmy
        if (ni, nj) in to_visit:
            to_visit.remove((ni, nj))
            narea, nperi = dfs(ni, nj)
            area += narea
            peri += nperi

    return area, peri
```
Łącząc cały kod w jedną całość uzyskujemy odpowiedź do pierwszej części
